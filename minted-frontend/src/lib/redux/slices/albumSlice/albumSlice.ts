/* Core */
import { createSlice, type PayloadAction } from '@reduxjs/toolkit';

/* Instruments */
import * as thunks from './thunks';
import { Album, AlbumMetadata, Song, SongMetadata } from './types';

/* Types */
export interface AlbumState {
  status: 'idle' | 'loading' | 'failed';
  loading: boolean;
  loadingAlbums: boolean;
  loadingSongs: boolean;
  loadingSoldAlbums: boolean;
  albums: Album[];
  albumMetadata: { [key: string]: AlbumMetadata };
  songs: Song[];
  songMetadata: { [key: string]: SongMetadata };
  soldAlbums: Album[];
}

const initialState: AlbumState = {
  status: 'idle',
  loading: false,
  loadingAlbums: false,
  loadingSongs: false,
  loadingSoldAlbums: false,
  albums: [],
  albumMetadata: {},
  songs: [],
  songMetadata: {},
  soldAlbums: [],
};

const filterAlbum = (albums: Album[], album: Album) => {
  return albums.filter((s) => !(s.contract === album.contract && s.albumid === album.albumid));
};

const filterSong = (songs: Song[], song: Song) => {
  return songs.filter(
    (s) => !(s.contract === song.contract && s.albumid === song.albumid && s.songid === song.songid)
  );
};

export const albumSlice = createSlice({
  name: 'admin',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setLoadingStatus: (state, action: PayloadAction<boolean>) => {
      state.status = action.payload ? 'loading' : 'idle';
    },
    setLoadingArtists: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setAlbums: (state, action: PayloadAction<Album[]>) => {
      state.albums = action.payload;
    },
    setAlbumMetadata: (state, action: PayloadAction<{ id: string; metadata: AlbumMetadata }>) => {
      if (action.payload.id) {
        state.albumMetadata[action.payload.id] = action.payload.metadata;
      }
    },
    setSoldAlbums: (state, action: PayloadAction<Album[]>) => {
      state.soldAlbums = action.payload;
    },
    setSongs: (state, action: PayloadAction<Song[]>) => {
      state.songs = action.payload;
    },
    setSongMetadata: (state, action: PayloadAction<{ id: string; metadata: SongMetadata }>) => {
      if (action.payload.id) {
        state.songMetadata[action.payload.id] = action.payload.metadata;
      }
    },
    removeAlbum: (state, action: PayloadAction<Album>) => {
      state.albums = filterAlbum(state.albums, action.payload);
    },
    removeSong: (state, action: PayloadAction<Song>) => {
      state.songs = filterSong(state.songs, action.payload);
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(thunks.fetchOwnedAlbumListAsync.pending, (state) => {
        state.loadingAlbums = true;
      })
      .addCase(thunks.fetchOwnedAlbumListAsync.rejected, (state) => {
        state.loadingAlbums = false;
      })
      .addCase(thunks.fetchOwnedAlbumListAsync.fulfilled, (state, action) => {
        state.loadingAlbums = false;
        state.albums = action.payload || [];
      })
      .addCase(thunks.fetchAllAlbumsAsync.pending, (state) => {
        state.loadingAlbums = true;
      })
      .addCase(thunks.fetchAllAlbumsAsync.fulfilled, (state, action) => {
        state.loadingAlbums = false;
        state.albums = action.payload || [];
      })
      .addCase(thunks.fetchAlbumByIdAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(thunks.fetchAlbumByIdAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        if (action.payload) {
          const album = action.payload;
          const index = state.albums.findIndex(
            (s) => s.contract === album.contract && s.albumid === album.albumid
          );
          if (index >= 0) {
            state.albums.splice(index, 1, album);
          } else {
            state.albums.push(album);
          }
        }
      })
      .addCase(thunks.fetchMintedAlbumListAsync.pending, (state) => {
        state.loadingAlbums = true;
      })
      .addCase(thunks.fetchMintedAlbumListAsync.fulfilled, (state, action) => {
        state.loadingAlbums = false;
        state.albums = action.payload;
      })
      .addCase(thunks.fetchSoldAlbumListAsync.pending, (state) => {
        state.loadingSoldAlbums = true;
      })
      .addCase(thunks.fetchSoldAlbumListAsync.fulfilled, (state, action) => {
        state.loadingSoldAlbums = false;
        state.soldAlbums = action.payload;
      })
      .addCase(thunks.fetchMintedSongListAsync.pending, (state) => {
        state.loadingSongs = true;
      })
      .addCase(thunks.fetchMintedSongListAsync.fulfilled, (state, action) => {
        state.loadingSongs = false;
        state.songs = action.payload || [];
      })
      .addCase(thunks.fetchAlbumSongListAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(thunks.fetchAlbumSongListAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.songs = action.payload || [];
      })
      .addCase(thunks.fetchSongByIdAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(thunks.fetchSongByIdAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        if (action.payload) {
          const song = action.payload;
          const index = state.songs.findIndex(
            (s) =>
              s.contract === song.contract && s.albumid === song.albumid && s.songid === song.songid
          );
          if (index >= 0) {
            state.songs.splice(index, 1, song);
          } else {
            state.songs.push(song);
          }
        }
      });
  },
});

export const {
  setLoadingStatus: setAlbumLoadingStatus,
  setAlbums,
  setAlbumMetadata,
  setSoldAlbums,
  setSongs,
  setSongMetadata,
  removeAlbum,
  removeSong,
} = albumSlice.actions;
