"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionBase = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_counters_1 = require("@subsquid/util-internal-counters");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("../util");
class ConnectionBase {
    constructor(options) {
        this.online = true;
        this.epoch = 0;
        this.backoffSchedule = [10, 100, 500, 2000, 10000, 20000];
        this.connectionErrors = 0;
        this.connectionErrorsInRow = 0;
        this.requestsServed = 0;
        this.speed = new util_internal_counters_1.Speed({
            windowSize: 200
        });
        this.closed = false;
        this.id = options.id;
        this.url = options.url;
        this.maxCapacity = options.capacity;
        this.capacity = this.maxCapacity;
        this.requestTimeout = options.requestTimeout;
        this.log = options.log;
        this.onlineCallback = options.onlineCallback;
    }
    getAvgResponseTime() {
        return this.speed.time() || 0.01;
    }
    getCapacity() {
        return this.capacity;
    }
    getMaxCapacity() {
        return this.maxCapacity;
    }
    getMetrics() {
        return {
            id: this.id,
            url: this.url,
            requestsServed: this.requestsServed,
            avgResponseTimeSeconds: this.speed.time(),
            connectionErrors: this.connectionErrors
        };
    }
    isOnline() {
        return this.online;
    }
    async send(req) {
        if (!this.online)
            return false;
        let epoch = this.epoch;
        let log = this.log?.child({ rpcRequestId: req.id });
        (0, assert_1.default)(this.capacity > 0);
        this.capacity -= 1;
        try {
            log?.debug('rpc send');
            let beg = (0, util_1.getTime)();
            let result = await this.call(req.id, req.method, req.params);
            let end = (0, util_1.getTime)();
            this.speed.push(1, beg, end);
            log?.debug({
                rpcTime: Math.round(Number(end - beg) / 1000000),
                rpcResult: result
            }, 'rpc result');
            req.resolve(result);
            this.connectionErrorsInRow = 0;
            this.requestsServed += 1;
            return true;
        }
        catch (err) {
            if (this.isRetryableError(err)) {
                log?.warn(err.toString());
                if (this.epoch == epoch)
                    this.backoff();
                return false;
            }
            else {
                (0, util_internal_1.addErrorContext)(err, {
                    rpcConnection: this.id,
                    rpcUrl: this.url,
                    rpcRequestId: req.id,
                    rpcMethod: req.method
                });
                req.reject(err);
                return true;
            }
        }
        finally {
            this.capacity += 1;
        }
    }
    backoff() {
        if (this.closed)
            return;
        let backoff = this.backoffSchedule[Math.min(this.connectionErrorsInRow, this.backoffSchedule.length - 1)];
        this.log?.warn(`going offline for ${backoff} ms`);
        this.connectionErrors += 1;
        this.connectionErrorsInRow += 1;
        this.epoch += 1;
        this.online = false;
        this.reconnectTimer = setTimeout(() => {
            this.reconnectTimer = undefined;
            this.reconnect().then(() => {
                this.log?.debug('online');
                this.online = true;
                this.onlineCallback?.();
            }, err => {
                this.log?.warn({ reason: err.toString() }, 'failed to reconnect');
                this.backoff();
            });
        }, backoff);
    }
    close() {
        this.closed = true;
        this.online = false;
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = undefined;
        }
        this.cleanup();
        this.log?.debug('closed');
    }
}
exports.ConnectionBase = ConnectionBase;
//# sourceMappingURL=base.js.map