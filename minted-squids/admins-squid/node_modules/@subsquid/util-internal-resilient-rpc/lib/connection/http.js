"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpRpcConnection = void 0;
const rpc_client_1 = require("@subsquid/rpc-client");
const util_internal_http_client_1 = require("@subsquid/util-internal-http-client");
const util_1 = require("../util");
const base_1 = require("./base");
class HttpRpcConnection extends base_1.ConnectionBase {
    constructor(options) {
        super(options);
        this.agent = new util_internal_http_client_1.HttpAgent({
            keepAlive: true
        });
        this.http = new util_internal_http_client_1.HttpClient({
            baseUrl: this.url,
            agent: this.agent,
            httpTimeout: this.requestTimeout
        });
    }
    async call(id, method, params) {
        let json = {
            jsonrpc: '2.0',
            id,
            method,
            params
        };
        let res = await this.http.post('/', {
            json,
            retryAttempts: 0
        });
        if (res.id != json.id)
            throw new rpc_client_1.RpcProtocolError(undefined, 'HTTP RPC response id does not match request id');
        if (res.error)
            throw new rpc_client_1.RpcError(res.error);
        return res.result;
    }
    isRetryableError(err) {
        if ((0, util_1.isRateLimitError)(err))
            return true;
        if ((0, util_internal_http_client_1.isHttpConnectionError)(err))
            return true;
        if (err instanceof util_internal_http_client_1.HttpTimeoutError)
            return true;
        if (err instanceof util_internal_http_client_1.HttpError) {
            switch (err.response.status) {
                case 429:
                case 502:
                case 503:
                case 504:
                    return true;
                default:
                    return false;
            }
        }
        return false;
    }
    async reconnect() { }
    cleanup() {
        this.agent.close();
    }
}
exports.HttpRpcConnection = HttpRpcConnection;
//# sourceMappingURL=http.js.map