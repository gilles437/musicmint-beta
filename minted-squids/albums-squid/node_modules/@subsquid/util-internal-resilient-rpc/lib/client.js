"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClient = void 0;
const rpc_client_1 = require("@subsquid/rpc-client");
const util_internal_1 = require("@subsquid/util-internal");
const http_1 = require("./connection/http");
const ws_1 = require("./connection/ws");
const queue_1 = require("./queue");
class RpcClient {
    constructor(options) {
        this.connections = [];
        this.queue = new queue_1.PriorityQueue();
        this.counter = 0;
        this.schedulingScheduled = false;
        this.closed = false;
        this.log = options.log;
        this.retryAttempts = options.retryAttempts ?? Number.MAX_SAFE_INTEGER;
        this.connections = options.endpoints.map((ep, id) => {
            let params = {
                id,
                url: ep.url,
                capacity: ep.capacity ?? 5,
                requestTimeout: options.requestTimeout ?? 20000,
                log: this.log?.child({ rpcConnection: id, rpcUrl: ep.url }),
                onlineCallback: () => this.schedule()
            };
            let protocol = new URL(ep.url).protocol;
            switch (protocol) {
                case 'ws:':
                case 'wss:':
                    return new ws_1.WsRpcConnection(params);
                case 'http:':
                case 'https:':
                    return new http_1.HttpRpcConnection(params);
                default:
                    throw new TypeError(`unsupported protocol: ${protocol}`);
            }
        });
    }
    getMetrics() {
        return this.connections.map(con => con.getMetrics()).sort((a, b) => a.id - b.id);
    }
    call(methodOrPriority, paramsOrMethod, args) {
        return new Promise((resolve, reject) => {
            if (this.closed)
                return reject(new rpc_client_1.RpcConnectionError('client was already closed'));
            let priority = 0;
            let method;
            let params;
            if (typeof methodOrPriority == 'string') {
                method = methodOrPriority;
                params = paramsOrMethod;
            }
            else {
                priority = methodOrPriority;
                method = paramsOrMethod;
                params = args;
            }
            let id = this.nextRequestId();
            this.log?.debug({
                rpcRequestId: id,
                rpcMethod: method,
                rpcParams: params
            }, 'rpc call');
            this.queue.push({
                id,
                priority,
                method,
                params,
                resolve,
                reject,
                retries: 0
            });
            this.schedule();
        });
    }
    nextRequestId() {
        return this.counter++;
    }
    schedule() {
        if (this.schedulingScheduled || this.queue.isEmpty())
            return;
        this.schedulingScheduled = true;
        process.nextTick(() => {
            this.schedulingScheduled = false;
            this.performScheduling();
        });
    }
    performScheduling() {
        this.connections.sort((a, b) => {
            let eta_a = a.getCapacity() > 0 ? a.getAvgResponseTime() : 3 * a.getAvgResponseTime();
            let eta_b = b.getCapacity() > 0 ? b.getAvgResponseTime() : 3 * b.getAvgResponseTime();
            return eta_a - eta_b;
        });
        let schedule = new Map();
        for (let i = 0; i < this.connections.length && !this.queue.isEmpty(); i++) {
            let con = this.connections[i];
            if (con.isOnline() && con.getCapacity() > 0) {
                let skip = this.willBeFetchedByFasterConnections(i, con.getAvgResponseTime());
                let requests = this.queue.take(skip, con.getCapacity());
                if (requests.length) {
                    schedule.set(con, requests);
                }
                else {
                    break;
                }
            }
        }
        if (Math.random() < 0.1) {
            this.moveLastRequestToRandomFreeConnection(schedule);
        }
        for (let [con, requests] of schedule) {
            for (let req of requests) {
                this.send(con, req);
            }
        }
    }
    willBeFetchedByFasterConnections(ci, deadline) {
        let n = 0;
        for (let i = 0; i < ci; i++) {
            let con = this.connections[i];
            if (con.isOnline()) {
                let avg = con.getAvgResponseTime();
                n += con.getMaxCapacity() * Math.floor(Math.max(deadline - 2 * avg, 0) / avg);
            }
        }
        return n;
    }
    moveLastRequestToRandomFreeConnection(schedule) {
        let free = this.connections.filter(c => {
            return c.isOnline() && c.getCapacity() == c.getMaxCapacity() && !schedule.has(c);
        });
        if (free.length == 0)
            return;
        let con = free[Math.floor(Math.random() * (free.length - 1))];
        let req = this.queue.takeLast() || this.stealLastRequest(schedule);
        schedule.set(con, [req]);
    }
    stealLastRequest(schedule) {
        let lastRequests;
        for (let requests of schedule.values()) {
            lastRequests = requests;
        }
        return lastRequests.pop();
    }
    send(con, req) {
        con.send(req).then(handled => {
            if (this.closed) {
                if (!handled)
                    req.reject(new rpc_client_1.RpcConnectionError('client was closed'));
            }
            else if (handled) {
                this.schedule();
            }
            else if (this.retryAttempts > req.retries) {
                req.retries += 1;
                this.queue.push(req);
                this.schedule();
            }
            else {
                req.reject((0, util_internal_1.addErrorContext)(new rpc_client_1.RpcConnectionError(`failed to perform a call after ${req.retries + 1} attempts`), {
                    rpcRequestId: req.id,
                    rpcRequestMethod: req.method
                }));
            }
        });
    }
    close() {
        if (this.closed)
            return;
        this.closed = true;
        for (let con of this.connections) {
            con.close();
        }
        for (let req of this.queue.takeAll()) {
            req.reject(new rpc_client_1.RpcConnectionError('client was closed'));
        }
    }
}
exports.RpcClient = RpcClient;
//# sourceMappingURL=client.js.map