"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metrics = void 0;
const util_internal_counters_1 = require("@subsquid/util-internal-counters");
const util_internal_prometheus_server_1 = require("@subsquid/util-internal-prometheus-server");
const prom_client_1 = require("prom-client");
class Metrics {
    collect(fn) {
        return function () {
            this.set(fn());
        };
    }
    constructor() {
        this.chainHeight = -1;
        this.ingestSpeed = new util_internal_counters_1.Speed({ windowSize: 5 });
        this.mappingSpeed = new util_internal_counters_1.Speed({ windowSize: 5 });
        this.mappingItemSpeed = new util_internal_counters_1.Speed({ windowSize: 5 });
        this.blockProgress = new util_internal_counters_1.Progress({ initialValue: 0 });
        this.registry = new prom_client_1.Registry();
        this.lastBlockGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_last_block',
            help: 'Last processed block',
            registers: [this.registry],
            aggregator: 'max'
        });
        this.chainHeightGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_chain_height',
            help: 'Chain height of the data source',
            registers: [this.registry],
            aggregator: 'max',
            collect: this.collect(() => this.chainHeight)
        });
        this.mappingSpeedGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_mapping_blocks_per_second',
            help: 'Mapping performance',
            registers: [this.registry],
            collect: this.collect(() => this.mappingSpeed.speed())
        });
        this.ingestSpeedGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_ingest_blocks_per_second',
            help: 'Data fetching speed',
            registers: [this.registry],
            collect: this.collect(() => this.ingestSpeed.speed())
        });
        this.syncEtaGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_sync_eta_seconds',
            help: 'Estimated time until all required blocks will be processed or until chain height will be reached',
            registers: [this.registry],
            collect: this.collect(() => this.blockProgress.eta())
        });
        this.syncRatioGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_sync_ratio',
            help: 'Percentage of processed blocks',
            registers: [this.registry],
            aggregator: 'max',
            collect: this.collect(() => this.blockProgress.ratio())
        });
        this.archiveHttpErrorsCounter = new prom_client_1.Counter({
            name: 'sqd_processor_archive_http_errors',
            help: 'Number of archive http connection errors',
            registers: [this.registry],
            aggregator: 'sum',
            labelNames: ['url']
        });
        (0, prom_client_1.collectDefaultMetrics)({ register: this.registry });
        this.setLastProcessedBlock(-1);
        this.setChainHeight(-1);
    }
    addChainRpcMetrics(client) {
        const gauge = (name, help, get) => {
            new prom_client_1.Gauge({
                name,
                help,
                registers: [this.registry],
                labelNames: ['id', 'url'],
                collect() {
                    for (let con of client.getMetrics()) {
                        this.set({ url: con.url, id: con.id }, get(con));
                    }
                }
            });
        };
        gauge('sqd_processor_chain_rpc_requests_served', 'Number of chain rpc requests served', con => con.requestsServed);
        gauge('sqd_processor_chain_rpc_errors', 'Number of chain rpc connection errors', con => con.connectionErrors);
        gauge('sqd_processor_chain_rpc_avg_response_time_seconds', 'Avg response time', con => con.avgResponseTimeSeconds);
    }
    setLastProcessedBlock(height) {
        this.lastBlockGauge.set(height);
    }
    setChainHeight(height) {
        this.chainHeight = height;
    }
    updateProgress(chainHeight, estimatedTotalBlocksCount, estimatedBlocksLeft, time) {
        this.setChainHeight(chainHeight);
        this.blockProgress.setTargetValue(estimatedTotalBlocksCount);
        this.blockProgress.setCurrentValue(estimatedTotalBlocksCount - estimatedBlocksLeft, time);
    }
    registerBatch(batchSize, batchItemSize, batchFetchStartTime, batchFetchEndTime, batchMappingStartTime, batchMappingEndTime) {
        this.ingestSpeed.push(batchSize, batchFetchStartTime, batchFetchEndTime);
        this.mappingSpeed.push(batchSize, batchMappingStartTime, batchMappingEndTime);
        this.mappingItemSpeed.push(batchItemSize, batchMappingStartTime, batchMappingEndTime);
    }
    registerArchiveRetry(url) {
        this.archiveHttpErrorsCounter.inc({ url });
    }
    getChainHeight() {
        return this.chainHeight;
    }
    getSyncSpeed() {
        return this.blockProgress.speed();
    }
    getSyncEtaSeconds() {
        return this.blockProgress.eta();
    }
    getSyncRatio() {
        return this.blockProgress.ratio();
    }
    getIngestSpeed() {
        return this.ingestSpeed.speed();
    }
    getMappingSpeed() {
        return this.mappingSpeed.speed();
    }
    getMappingItemSpeed() {
        return this.mappingItemSpeed.speed();
    }
    serve(port) {
        return (0, util_internal_prometheus_server_1.createPrometheusServer)(this.registry, port);
    }
}
exports.Metrics = Metrics;
//# sourceMappingURL=metrics.js.map